# Server-side resource loading

## Protocol

The VoxelCsgApplied protocol message was hijacked to allow sending resources
(.nqdef, .node, meshes, soundbanks...) to the client.

The VoxelEdit payload must have constructId set to 0. Its behavior changes
based on the "flags" field:

1: load .nqdef from "operation" field (JSON data)

2: load any file into Unigine cache. File content is in "operation" field,
and relative file path in "hashContext"

3: Send an element load request with element name in "hashContext". This must
be sent for new elements, after sending all .nqdefs, nodes, meshes, ...

4: load a sound bank with file content in "operation". Note: wwise is picky
about what it accepts. Our init sound bank has project ID 0xCF0E in memory (3791),
and is version 135, generated by Wwise version 2019.2.x.

5: load a CSV file into the localization system

To ensure your new resources are available before constructs are being loaded,
it is recomended to inject them synchronously as soon as possible, for instance
in a DLL Mod's GetModInfoFor() method.

## Sample Mod

The Mod in this directory will send every file at the root of 'Mods/client' directory to each
connecting client, based on the file extension:

- .nqdef : sent to client asset manager
- .bnk : sent as sound bank
- .csv : sent as localization data
- .elr : plain text file with one element name per line, sent as element reload requests at the end
- everything else : sent to unigine filesystem RAM disk

If the file 'voxels.load' is present, voxel materials and textures will be reloaded
by the client. Use it if you inject new voxels.

Note that cached resource will be
sent with a "resources_generated/" filesystem prefix, which is required for
further resources loading by the client. Be sure to adjust your .nqdef and .node
accordingly.

## Warning

Always use lowercase file names or resource files may fail to load.

If you create new skins for elements, an element load request (see .elr above) must be sent with the
full element name "ElementName_SkinName".

If "inherit" is used in nqdefs, element load requests must be sent in proper order (parent first).

## Client-side encrypted disk caching

Starting from server 1.5.3 and client 1.4.6 assets can be cached by the client.

### Protocol

A two-step process is used:

First the server send a VoxelCsgApplied with flag 7, and a serialized json
of "AssetManifest" in hashContext.

This structure (declared in NQStruct-advanced.def) contains the encryption key
and list of assets to load from cache.

The client upon reception loads all the data it has in cache, and then sends a
ModAction call to mod "Loader" with actionId "10000", and as payload
a serialized AssetManifest containing what was not loaded from cache.

The server then sends the missing data, prefining file paths in hashContext
with "<secret_key>*" (that is the 32 bytes key expressed in hex then a star).

Finally the server sends optional element reload requests, and voxel load request.

The new data will be cached and loaded by the client.

Note: the client processes voxel and element reload upon manifest
reception if and only if everything was loaded from cache.

### Using ModLoader

Simply create a file named "secret.key" with a hex-encoded 32 bytes random value
to activate the feature.

## Synchronous mode

Starting from client 1.4.7 asset loading can happen synchronously at the start
of the login sequence.

The client enables this mode if it detects a Mod named "SyncLoader".

It then sends a manifest request by pushing a ModAction to SyncLoader
with code 0. The login sequence will remain frozen until a VoxelCsgApplied
is received with flag 8, unless everything in a received manifest is loaded
from cache.

The manifest must be sent as a VoxelCsgApplied with flag 17 instead of 7, so
that the client knows to send ModAction with delta to "SyncLoader" instead of
"Loader"

## Compression

Starting from client 1.4.10 if a loaded resource file (not nqdef!) has extension '.nqz'
it will be recognized as a NQ compressed file and decompressed before injection into the
unigine virtual file system.

To generate nqz files one can use the 'nqcompress.py' script provided in this directory.

## Sample voxel nqdef

This sample expect files "<name>_c.dds", "<name>_n.dds" and "<name>_mrao.dds"
to be injected also.


```json
{
  "worlds": {
    "voxel": {
      "materialDefinitions": {
        "hcombs_v1": {
          "materialType": "non_blending",
          "layers": [
            "c",
            "n",
            "mrao"
          ],
          "materials": {
            "MyCoolVoxelHC": {
              "texture": "resources_generated/<name>",
              "albedo": [
                0.5,
                0.5,
                0.5
              ]
            }
          }
        }
      }
    }
  }
}
```
